   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"base64url.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.base64_encode,"ax",%progbits
  17              		.align	1
  18              		.global	base64_encode
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	base64_encode:
  25              	.LFB1:
  26              		.file 1 "base64url.c"
   1:base64url.c   **** /* base64url.c -- Encode binary data using printable characters.
   2:base64url.c   ****    Copyright (C) 1999, 2000, 2001, 2004, 2005, 2006 Free Software
   3:base64url.c   ****    Foundation, Inc.
   4:base64url.c   **** 
   5:base64url.c   ****    This program is free software; you can redistribute it and/or modify
   6:base64url.c   ****    it under the terms of the GNU General Public License as published by
   7:base64url.c   ****    the Free Software Foundation; either version 2, or (at your option)
   8:base64url.c   ****    any later version.
   9:base64url.c   **** 
  10:base64url.c   ****    This program is distributed in the hope that it will be useful,
  11:base64url.c   ****    but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:base64url.c   ****    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:base64url.c   ****    GNU General Public License for more details.
  14:base64url.c   **** 
  15:base64url.c   ****    You should have received a copy of the GNU General Public License
  16:base64url.c   ****    along with this program; if not, write to the Free Software Foundation,
  17:base64url.c   ****    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
  18:base64url.c   **** 
  19:base64url.c   **** /* Written by Simon Josefsson.  Partially adapted from GNU MailUtils
  20:base64url.c   ****  * (mailbox/filter_trans.c, as of 2004-11-28).  Improved by review
  21:base64url.c   ****  * from Paul Eggert, Bruno Haible, and Stepan Kasal.
  22:base64url.c   ****  *
  23:base64url.c   ****  * See also RFC 3548 <http://www.ietf.org/rfc/rfc3548.txt>.
  24:base64url.c   ****  *
  25:base64url.c   ****  * Be careful with error checking.  Here is how you would typically
  26:base64url.c   ****  * use these functions:
  27:base64url.c   ****  *
  28:base64url.c   ****  * bool ok = base64_decode_alloc (in, inlen, &out, &outlen);
  29:base64url.c   ****  * if (!ok)
  30:base64url.c   ****  *   FAIL: input was not valid base64
  31:base64url.c   ****  * if (out == NULL)
  32:base64url.c   ****  *   FAIL: memory allocation error
  33:base64url.c   ****  * OK: data in OUT/OUTLEN
  34:base64url.c   ****  *
  35:base64url.c   ****  * size_t outlen = base64_encode_alloc (in, inlen, &out);
  36:base64url.c   ****  * if (out == NULL && outlen == 0 && inlen != 0)
  37:base64url.c   ****  *   FAIL: input too long
  38:base64url.c   ****  * if (out == NULL)
  39:base64url.c   ****  *   FAIL: memory allocation error
  40:base64url.c   ****  * OK: data in OUT/OUTLEN.
  41:base64url.c   ****  *
  42:base64url.c   ****  */
  43:base64url.c   **** 
  44:base64url.c   **** /* Adapted to URL safe alphabet by Florian Wilde on 2017-12-04
  45:base64url.c   ****  */
  46:base64url.c   **** 
  47:base64url.c   **** //#include <config.h>
  48:base64url.c   **** #include <stdbool.h>
  49:base64url.c   **** 
  50:base64url.c   **** /* Get prototype. */
  51:base64url.c   **** #include "base64url.h"
  52:base64url.c   **** 
  53:base64url.c   **** /* Get malloc. */
  54:base64url.c   **** #include <stdlib.h>
  55:base64url.c   **** 
  56:base64url.c   **** /* Get UCHAR_MAX. */
  57:base64url.c   **** #include <limits.h>
  58:base64url.c   **** 
  59:base64url.c   **** /* C89 compliant way to cast 'char' to 'unsigned char'. */
  60:base64url.c   **** static inline unsigned char
  61:base64url.c   **** to_uchar (char ch)
  62:base64url.c   **** {
  63:base64url.c   ****   return ch;
  64:base64url.c   **** }
  65:base64url.c   **** 
  66:base64url.c   **** /* Base64 encode IN array of size INLEN into OUT array of size OUTLEN.
  67:base64url.c   ****    If OUTLEN is less than BASE64_LENGTH(INLEN), write as many bytes as
  68:base64url.c   ****    possible.  If OUTLEN is larger than BASE64_LENGTH(INLEN), also zero
  69:base64url.c   ****    terminate the output buffer. */
  70:base64url.c   **** void
  71:base64url.c   **** base64_encode (const char *restrict in, size_t inlen,
  72:base64url.c   **** 	       char *restrict out, size_t outlen)
  73:base64url.c   **** {
  27              		.loc 1 73 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  74:base64url.c   ****   static const char b64str[64] =
  75:base64url.c   ****     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  76:base64url.c   **** 
  77:base64url.c   ****   while (inlen && outlen)
  32              		.loc 1 77 0
  33 0000 0029     		cmp	r1, #0
  34 0002 54D0     		beq	.L2
  73:base64url.c   ****   static const char b64str[64] =
  35              		.loc 1 73 0
  36 0004 F0B5     		push	{r4, r5, r6, r7, lr}
  37              	.LCFI0:
  38              		.cfi_def_cfa_offset 20
  39              		.cfi_offset 4, -20
  40              		.cfi_offset 5, -16
  41              		.cfi_offset 6, -12
  42              		.cfi_offset 7, -8
  43              		.cfi_offset 14, -4
  44 0006 0F46     		mov	r7, r1
  45              		.loc 1 77 0
  46 0008 EBB1     		cbz	r3, .L1
  78:base64url.c   ****     {
  79:base64url.c   ****       *out++ = b64str[(to_uchar (in[0]) >> 2) & 0x3f];
  47              		.loc 1 79 0
  48 000a 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
  49              	.LVL1:
  50 000c 8C08     		lsrs	r4, r1, #2
  51 000e 2A4D     		ldr	r5, .L19
  52 0010 2C5D     		ldrb	r4, [r5, r4]	@ zero_extendqisi2
  53 0012 1470     		strb	r4, [r2]
  54              	.LVL2:
  80:base64url.c   ****       if (!--outlen)
  55              		.loc 1 80 0
  56 0014 012B     		cmp	r3, #1
  57 0016 16D0     		beq	.L1
  81:base64url.c   **** 	break;
  82:base64url.c   ****       *out++ = b64str[((to_uchar (in[0]) << 4)
  83:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  84:base64url.c   **** 		      & 0x3f];
  85:base64url.c   ****       if (!--outlen)
  86:base64url.c   **** 	break;
  87:base64url.c   ****       *out++ =
  88:base64url.c   **** 	(inlen
  89:base64url.c   **** 	 ? b64str[((to_uchar (in[1]) << 2)
  90:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
  91:base64url.c   **** 		  & 0x3f]
  92:base64url.c   **** 	 : '=');
  93:base64url.c   ****       if (!--outlen)
  94:base64url.c   **** 	break;
  95:base64url.c   ****       *out++ = inlen ? b64str[to_uchar (in[2]) & 0x3f] : '=';
  58              		.loc 1 95 0
  59 0018 3D25     		movs	r5, #61
  87:base64url.c   **** 	(inlen
  60              		.loc 1 87 0
  61 001a 274C     		ldr	r4, .L19
  90:base64url.c   **** 		  & 0x3f]
  62              		.loc 1 90 0
  63 001c 4FF0000E 		mov	lr, #0
  64 0020 1EE0     		b	.L11
  65              	.LVL3:
  66              	.L4:
  84:base64url.c   ****       if (!--outlen)
  67              		.loc 1 84 0 discriminator 4
  68 0022 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  69              		.loc 1 82 0 discriminator 4
  70 0026 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
  71 0028 5170     		strb	r1, [r2, #1]
  72              	.LVL4:
  85:base64url.c   **** 	break;
  73              		.loc 1 85 0 discriminator 4
  74 002a 022B     		cmp	r3, #2
  75 002c 0BD0     		beq	.L1
  87:base64url.c   **** 	(inlen
  76              		.loc 1 87 0
  77 002e 26BB     		cbnz	r6, .L5
  78              	.LVL5:
  79 0030 9570     		strb	r5, [r2, #2]
  80              	.LVL6:
  93:base64url.c   **** 	break;
  81              		.loc 1 93 0
  82 0032 032B     		cmp	r3, #3
  83 0034 07D0     		beq	.L1
  84              	.LVL7:
  85              	.L8:
  86 0036 0432     		adds	r2, r2, #4
  87              	.LVL8:
  88              		.loc 1 95 0 discriminator 4
  89 0038 02F8015C 		strb	r5, [r2, #-1]
  90              	.LVL9:
  96:base64url.c   ****       if (!--outlen)
  91              		.loc 1 96 0 discriminator 4
  92 003c 043B     		subs	r3, r3, #4
  93              	.LVL10:
  94 003e 02D0     		beq	.L1
  97:base64url.c   **** 	break;
  98:base64url.c   ****       if (inlen)
  95              		.loc 1 98 0
  96 0040 16B9     		cbnz	r6, .L9
  97              	.L10:
  98              	.LVL11:
  99:base64url.c   **** 	inlen--;
 100:base64url.c   ****       if (inlen)
 101:base64url.c   **** 	in += 3;
 102:base64url.c   ****     }
 103:base64url.c   **** 
 104:base64url.c   ****   if (outlen)
 105:base64url.c   ****     *out = '\0';
  99              		.loc 1 105 0
 100 0042 0023     		movs	r3, #0
 101 0044 1370     		strb	r3, [r2]
 102              	.LVL12:
 103              	.L1:
 106:base64url.c   **** }
 104              		.loc 1 106 0
 105 0046 F0BD     		pop	{r4, r5, r6, r7, pc}
 106              	.LVL13:
 107              	.L9:
 100:base64url.c   **** 	in += 3;
 108              		.loc 1 100 0
 109 0048 771E     		subs	r7, r6, #1
 110              	.LVL14:
 111 004a FAD0     		beq	.L10
  79:base64url.c   ****       if (!--outlen)
 112              		.loc 1 79 0
 113 004c 10F8031F 		ldrb	r1, [r0, #3]!	@ zero_extendqisi2
 114              	.LVL15:
 115 0050 4FEA910C 		lsr	ip, r1, #2
 116 0054 14F80CC0 		ldrb	ip, [r4, ip]	@ zero_extendqisi2
 117 0058 82F800C0 		strb	ip, [r2]
 118              	.LVL16:
  80:base64url.c   **** 	break;
 119              		.loc 1 80 0
 120 005c 012B     		cmp	r3, #1
 121 005e F2D0     		beq	.L1
 122              	.LVL17:
 123              	.L11:
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 124              		.loc 1 82 0
 125 0060 0901     		lsls	r1, r1, #4
 126              	.LVL18:
  83:base64url.c   **** 		      & 0x3f];
 127              		.loc 1 83 0
 128 0062 7E1E     		subs	r6, r7, #1
 129              	.LVL19:
 130 0064 DDD0     		beq	.L4
 131              	.LVL20:
  83:base64url.c   **** 		      & 0x3f];
 132              		.loc 1 83 0 is_stmt 0 discriminator 1
 133 0066 90F801C0 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
 134 006a 01EB1C11 		add	r1, r1, ip, lsr #4
  84:base64url.c   ****       if (!--outlen)
 135              		.loc 1 84 0 is_stmt 1 discriminator 1
 136 006e 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 137              		.loc 1 82 0 discriminator 1
 138 0072 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 139 0074 5170     		strb	r1, [r2, #1]
 140              	.LVL21:
  85:base64url.c   **** 	break;
 141              		.loc 1 85 0 discriminator 1
 142 0076 022B     		cmp	r3, #2
 143 0078 E5D0     		beq	.L1
 144              	.LVL22:
 145              	.L5:
  89:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
 146              		.loc 1 89 0
 147 007a 4178     		ldrb	r1, [r0, #1]	@ zero_extendqisi2
 148 007c 8900     		lsls	r1, r1, #2
 149              	.LVL23:
  90:base64url.c   **** 		  & 0x3f]
 150              		.loc 1 90 0
 151 007e BE1E     		subs	r6, r7, #2
 152              	.LVL24:
 153 0080 1ABF     		itte	ne
 154 0082 8778     		ldrbne	r7, [r0, #2]	@ zero_extendqisi2
 155 0084 BF09     		lsrne	r7, r7, #6
 156 0086 7746     		moveq	r7, lr
 157              	.LVL25:
 158 0088 3944     		add	r1, r1, r7
  91:base64url.c   **** 	 : '=');
 159              		.loc 1 91 0
 160 008a 01F03F01 		and	r1, r1, #63
  87:base64url.c   **** 	(inlen
 161              		.loc 1 87 0
 162 008e 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 163 0090 9170     		strb	r1, [r2, #2]
 164              	.LVL26:
  93:base64url.c   **** 	break;
 165              		.loc 1 93 0
 166 0092 032B     		cmp	r3, #3
 167 0094 D7D0     		beq	.L1
  95:base64url.c   ****       if (!--outlen)
 168              		.loc 1 95 0
 169 0096 002E     		cmp	r6, #0
 170 0098 CDD0     		beq	.L8
 171 009a 0432     		adds	r2, r2, #4
 172              	.LVL27:
  95:base64url.c   ****       if (!--outlen)
 173              		.loc 1 95 0 is_stmt 0 discriminator 1
 174 009c 8178     		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 175 009e 01F03F01 		and	r1, r1, #63
 176 00a2 615C     		ldrb	r1, [r4, r1]	@ zero_extendqisi2
 177 00a4 02F8011C 		strb	r1, [r2, #-1]
 178              	.LVL28:
  96:base64url.c   **** 	break;
 179              		.loc 1 96 0 is_stmt 1 discriminator 1
 180 00a8 043B     		subs	r3, r3, #4
 181              	.LVL29:
 182 00aa CDD1     		bne	.L9
 183 00ac CBE7     		b	.L1
 184              	.LVL30:
 185              	.L2:
 186              	.LCFI1:
 187              		.cfi_def_cfa_offset 0
 188              		.cfi_restore 4
 189              		.cfi_restore 5
 190              		.cfi_restore 6
 191              		.cfi_restore 7
 192              		.cfi_restore 14
 104:base64url.c   ****     *out = '\0';
 193              		.loc 1 104 0
 194 00ae 0BB1     		cbz	r3, .L16
 195              	.LVL31:
 105:base64url.c   **** }
 196              		.loc 1 105 0
 197 00b0 0023     		movs	r3, #0
 198 00b2 1370     		strb	r3, [r2]
 199              	.L16:
 200 00b4 7047     		bx	lr
 201              	.L20:
 202 00b6 00BF     		.align	2
 203              	.L19:
 204 00b8 00000000 		.word	.LANCHOR0
 205              		.cfi_endproc
 206              	.LFE1:
 208              		.section	.text.base64_encode_alloc,"ax",%progbits
 209              		.align	1
 210              		.global	base64_encode_alloc
 211              		.syntax unified
 212              		.thumb
 213              		.thumb_func
 214              		.fpu fpv4-sp-d16
 216              	base64_encode_alloc:
 217              	.LFB2:
 107:base64url.c   **** 
 108:base64url.c   **** /* Allocate a buffer and store zero terminated base64 encoded data
 109:base64url.c   ****    from array IN of size INLEN, returning BASE64_LENGTH(INLEN), i.e.,
 110:base64url.c   ****    the length of the encoded data, excluding the terminating zero.  On
 111:base64url.c   ****    return, the OUT variable will hold a pointer to newly allocated
 112:base64url.c   ****    memory that must be deallocated by the caller.  If output string
 113:base64url.c   ****    length would overflow, 0 is returned and OUT is set to NULL.  If
 114:base64url.c   ****    memory allocation failed, OUT is set to NULL, and the return value
 115:base64url.c   ****    indicates length of the requested memory block, i.e.,
 116:base64url.c   ****    BASE64_LENGTH(inlen) + 1. */
 117:base64url.c   **** size_t
 118:base64url.c   **** base64_encode_alloc (const char *in, size_t inlen, char **out)
 119:base64url.c   **** {
 218              		.loc 1 119 0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
 222              	.LVL32:
 223 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 224              	.LCFI2:
 225              		.cfi_def_cfa_offset 24
 226              		.cfi_offset 4, -24
 227              		.cfi_offset 5, -20
 228              		.cfi_offset 6, -16
 229              		.cfi_offset 7, -12
 230              		.cfi_offset 8, -8
 231              		.cfi_offset 14, -4
 120:base64url.c   ****   size_t outlen = 1 + BASE64_LENGTH (inlen);
 232              		.loc 1 120 0
 233 0004 8C1C     		adds	r4, r1, #2
 234 0006 0F4B     		ldr	r3, .L25
 235 0008 A3FB0434 		umull	r3, r4, r3, r4
 236 000c 6408     		lsrs	r4, r4, #1
 237 000e A400     		lsls	r4, r4, #2
 238 0010 651C     		adds	r5, r4, #1
 239              	.LVL33:
 121:base64url.c   **** 
 122:base64url.c   ****   /* Check for overflow in outlen computation.
 123:base64url.c   ****    *
 124:base64url.c   ****    * If there is no overflow, outlen >= inlen.
 125:base64url.c   ****    *
 126:base64url.c   ****    * If the operation (inlen + 2) overflows then it yields at most +1, so
 127:base64url.c   ****    * outlen is 0.
 128:base64url.c   ****    *
 129:base64url.c   ****    * If the multiplication overflows, we lose at least half of the
 130:base64url.c   ****    * correct value, so the result is < ((inlen + 2) / 3) * 2, which is
 131:base64url.c   ****    * less than (inlen + 2) * 0.66667, which is less than inlen as soon as
 132:base64url.c   ****    * (inlen > 4).
 133:base64url.c   ****    */
 134:base64url.c   ****   if (inlen > outlen)
 240              		.loc 1 134 0
 241 0012 A942     		cmp	r1, r5
 242 0014 04D9     		bls	.L22
 135:base64url.c   ****     {
 136:base64url.c   ****       *out = NULL;
 243              		.loc 1 136 0
 244 0016 0025     		movs	r5, #0
 245              	.LVL34:
 246 0018 1560     		str	r5, [r2]
 247              	.LVL35:
 248              	.L21:
 137:base64url.c   ****       return 0;
 138:base64url.c   ****     }
 139:base64url.c   **** 
 140:base64url.c   ****   *out = malloc (outlen);
 141:base64url.c   ****   if (!*out)
 142:base64url.c   ****     return outlen;
 143:base64url.c   **** 
 144:base64url.c   ****   base64_encode (in, inlen, *out, outlen);
 145:base64url.c   **** 
 146:base64url.c   ****   return outlen - 1;
 147:base64url.c   **** }
 249              		.loc 1 147 0
 250 001a 2846     		mov	r0, r5
 251 001c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 252              	.LVL36:
 253              	.L22:
 254 0020 1746     		mov	r7, r2
 255 0022 0E46     		mov	r6, r1
 256 0024 8046     		mov	r8, r0
 140:base64url.c   ****   if (!*out)
 257              		.loc 1 140 0
 258 0026 2846     		mov	r0, r5
 259              	.LVL37:
 260 0028 FFF7FEFF 		bl	malloc
 261              	.LVL38:
 262 002c 3860     		str	r0, [r7]
 141:base64url.c   ****     return outlen;
 263              		.loc 1 141 0
 264 002e 0028     		cmp	r0, #0
 265 0030 F3D0     		beq	.L21
 144:base64url.c   **** 
 266              		.loc 1 144 0
 267 0032 2B46     		mov	r3, r5
 268 0034 0246     		mov	r2, r0
 269 0036 3146     		mov	r1, r6
 270 0038 4046     		mov	r0, r8
 271 003a FFF7FEFF 		bl	base64_encode
 272              	.LVL39:
 146:base64url.c   **** }
 273              		.loc 1 146 0
 274 003e 2546     		mov	r5, r4
 275              	.LVL40:
 276 0040 EBE7     		b	.L21
 277              	.L26:
 278 0042 00BF     		.align	2
 279              	.L25:
 280 0044 ABAAAAAA 		.word	-1431655765
 281              		.cfi_endproc
 282              	.LFE2:
 284              		.section	.text.isbase64,"ax",%progbits
 285              		.align	1
 286              		.global	isbase64
 287              		.syntax unified
 288              		.thumb
 289              		.thumb_func
 290              		.fpu fpv4-sp-d16
 292              	isbase64:
 293              	.LFB3:
 148:base64url.c   **** 
 149:base64url.c   **** /* With this approach this file works independent of the charset used
 150:base64url.c   ****    (think EBCDIC).  However, it does assume that the characters in the
 151:base64url.c   ****    Base64url alphabet (A-Z,a-z,0-9,-,_) are encoded in 0..255.  POSIX
 152:base64url.c   ****    1003.1-2001 require that char and unsigned char are 8-bit
 153:base64url.c   ****    quantities, though, taking care of that problem.  But this may be a
 154:base64url.c   ****    potential problem on non-POSIX C99 platforms.
 155:base64url.c   **** 
 156:base64url.c   ****    IBM C V6 for AIX mishandles "#define B64(x) ...'x'...", so use "_"
 157:base64url.c   ****    as the formal parameter rather than "x".  */
 158:base64url.c   **** #define B64(_)					\
 159:base64url.c   ****   ((_) == 'A' ? 0				\
 160:base64url.c   ****    : (_) == 'B' ? 1				\
 161:base64url.c   ****    : (_) == 'C' ? 2				\
 162:base64url.c   ****    : (_) == 'D' ? 3				\
 163:base64url.c   ****    : (_) == 'E' ? 4				\
 164:base64url.c   ****    : (_) == 'F' ? 5				\
 165:base64url.c   ****    : (_) == 'G' ? 6				\
 166:base64url.c   ****    : (_) == 'H' ? 7				\
 167:base64url.c   ****    : (_) == 'I' ? 8				\
 168:base64url.c   ****    : (_) == 'J' ? 9				\
 169:base64url.c   ****    : (_) == 'K' ? 10				\
 170:base64url.c   ****    : (_) == 'L' ? 11				\
 171:base64url.c   ****    : (_) == 'M' ? 12				\
 172:base64url.c   ****    : (_) == 'N' ? 13				\
 173:base64url.c   ****    : (_) == 'O' ? 14				\
 174:base64url.c   ****    : (_) == 'P' ? 15				\
 175:base64url.c   ****    : (_) == 'Q' ? 16				\
 176:base64url.c   ****    : (_) == 'R' ? 17				\
 177:base64url.c   ****    : (_) == 'S' ? 18				\
 178:base64url.c   ****    : (_) == 'T' ? 19				\
 179:base64url.c   ****    : (_) == 'U' ? 20				\
 180:base64url.c   ****    : (_) == 'V' ? 21				\
 181:base64url.c   ****    : (_) == 'W' ? 22				\
 182:base64url.c   ****    : (_) == 'X' ? 23				\
 183:base64url.c   ****    : (_) == 'Y' ? 24				\
 184:base64url.c   ****    : (_) == 'Z' ? 25				\
 185:base64url.c   ****    : (_) == 'a' ? 26				\
 186:base64url.c   ****    : (_) == 'b' ? 27				\
 187:base64url.c   ****    : (_) == 'c' ? 28				\
 188:base64url.c   ****    : (_) == 'd' ? 29				\
 189:base64url.c   ****    : (_) == 'e' ? 30				\
 190:base64url.c   ****    : (_) == 'f' ? 31				\
 191:base64url.c   ****    : (_) == 'g' ? 32				\
 192:base64url.c   ****    : (_) == 'h' ? 33				\
 193:base64url.c   ****    : (_) == 'i' ? 34				\
 194:base64url.c   ****    : (_) == 'j' ? 35				\
 195:base64url.c   ****    : (_) == 'k' ? 36				\
 196:base64url.c   ****    : (_) == 'l' ? 37				\
 197:base64url.c   ****    : (_) == 'm' ? 38				\
 198:base64url.c   ****    : (_) == 'n' ? 39				\
 199:base64url.c   ****    : (_) == 'o' ? 40				\
 200:base64url.c   ****    : (_) == 'p' ? 41				\
 201:base64url.c   ****    : (_) == 'q' ? 42				\
 202:base64url.c   ****    : (_) == 'r' ? 43				\
 203:base64url.c   ****    : (_) == 's' ? 44				\
 204:base64url.c   ****    : (_) == 't' ? 45				\
 205:base64url.c   ****    : (_) == 'u' ? 46				\
 206:base64url.c   ****    : (_) == 'v' ? 47				\
 207:base64url.c   ****    : (_) == 'w' ? 48				\
 208:base64url.c   ****    : (_) == 'x' ? 49				\
 209:base64url.c   ****    : (_) == 'y' ? 50				\
 210:base64url.c   ****    : (_) == 'z' ? 51				\
 211:base64url.c   ****    : (_) == '0' ? 52				\
 212:base64url.c   ****    : (_) == '1' ? 53				\
 213:base64url.c   ****    : (_) == '2' ? 54				\
 214:base64url.c   ****    : (_) == '3' ? 55				\
 215:base64url.c   ****    : (_) == '4' ? 56				\
 216:base64url.c   ****    : (_) == '5' ? 57				\
 217:base64url.c   ****    : (_) == '6' ? 58				\
 218:base64url.c   ****    : (_) == '7' ? 59				\
 219:base64url.c   ****    : (_) == '8' ? 60				\
 220:base64url.c   ****    : (_) == '9' ? 61				\
 221:base64url.c   ****    : (_) == '-' ? 62				\
 222:base64url.c   ****    : (_) == '_' ? 63				\
 223:base64url.c   ****    : -1)
 224:base64url.c   **** 
 225:base64url.c   **** static const signed char b64[0x100] = {
 226:base64url.c   ****   B64 (0), B64 (1), B64 (2), B64 (3),
 227:base64url.c   ****   B64 (4), B64 (5), B64 (6), B64 (7),
 228:base64url.c   ****   B64 (8), B64 (9), B64 (10), B64 (11),
 229:base64url.c   ****   B64 (12), B64 (13), B64 (14), B64 (15),
 230:base64url.c   ****   B64 (16), B64 (17), B64 (18), B64 (19),
 231:base64url.c   ****   B64 (20), B64 (21), B64 (22), B64 (23),
 232:base64url.c   ****   B64 (24), B64 (25), B64 (26), B64 (27),
 233:base64url.c   ****   B64 (28), B64 (29), B64 (30), B64 (31),
 234:base64url.c   ****   B64 (32), B64 (33), B64 (34), B64 (35),
 235:base64url.c   ****   B64 (36), B64 (37), B64 (38), B64 (39),
 236:base64url.c   ****   B64 (40), B64 (41), B64 (42), B64 (43),
 237:base64url.c   ****   B64 (44), B64 (45), B64 (46), B64 (47),
 238:base64url.c   ****   B64 (48), B64 (49), B64 (50), B64 (51),
 239:base64url.c   ****   B64 (52), B64 (53), B64 (54), B64 (55),
 240:base64url.c   ****   B64 (56), B64 (57), B64 (58), B64 (59),
 241:base64url.c   ****   B64 (60), B64 (61), B64 (62), B64 (63),
 242:base64url.c   ****   B64 (64), B64 (65), B64 (66), B64 (67),
 243:base64url.c   ****   B64 (68), B64 (69), B64 (70), B64 (71),
 244:base64url.c   ****   B64 (72), B64 (73), B64 (74), B64 (75),
 245:base64url.c   ****   B64 (76), B64 (77), B64 (78), B64 (79),
 246:base64url.c   ****   B64 (80), B64 (81), B64 (82), B64 (83),
 247:base64url.c   ****   B64 (84), B64 (85), B64 (86), B64 (87),
 248:base64url.c   ****   B64 (88), B64 (89), B64 (90), B64 (91),
 249:base64url.c   ****   B64 (92), B64 (93), B64 (94), B64 (95),
 250:base64url.c   ****   B64 (96), B64 (97), B64 (98), B64 (99),
 251:base64url.c   ****   B64 (100), B64 (101), B64 (102), B64 (103),
 252:base64url.c   ****   B64 (104), B64 (105), B64 (106), B64 (107),
 253:base64url.c   ****   B64 (108), B64 (109), B64 (110), B64 (111),
 254:base64url.c   ****   B64 (112), B64 (113), B64 (114), B64 (115),
 255:base64url.c   ****   B64 (116), B64 (117), B64 (118), B64 (119),
 256:base64url.c   ****   B64 (120), B64 (121), B64 (122), B64 (123),
 257:base64url.c   ****   B64 (124), B64 (125), B64 (126), B64 (127),
 258:base64url.c   ****   B64 (128), B64 (129), B64 (130), B64 (131),
 259:base64url.c   ****   B64 (132), B64 (133), B64 (134), B64 (135),
 260:base64url.c   ****   B64 (136), B64 (137), B64 (138), B64 (139),
 261:base64url.c   ****   B64 (140), B64 (141), B64 (142), B64 (143),
 262:base64url.c   ****   B64 (144), B64 (145), B64 (146), B64 (147),
 263:base64url.c   ****   B64 (148), B64 (149), B64 (150), B64 (151),
 264:base64url.c   ****   B64 (152), B64 (153), B64 (154), B64 (155),
 265:base64url.c   ****   B64 (156), B64 (157), B64 (158), B64 (159),
 266:base64url.c   ****   B64 (160), B64 (161), B64 (162), B64 (163),
 267:base64url.c   ****   B64 (164), B64 (165), B64 (166), B64 (167),
 268:base64url.c   ****   B64 (168), B64 (169), B64 (170), B64 (171),
 269:base64url.c   ****   B64 (172), B64 (173), B64 (174), B64 (175),
 270:base64url.c   ****   B64 (176), B64 (177), B64 (178), B64 (179),
 271:base64url.c   ****   B64 (180), B64 (181), B64 (182), B64 (183),
 272:base64url.c   ****   B64 (184), B64 (185), B64 (186), B64 (187),
 273:base64url.c   ****   B64 (188), B64 (189), B64 (190), B64 (191),
 274:base64url.c   ****   B64 (192), B64 (193), B64 (194), B64 (195),
 275:base64url.c   ****   B64 (196), B64 (197), B64 (198), B64 (199),
 276:base64url.c   ****   B64 (200), B64 (201), B64 (202), B64 (203),
 277:base64url.c   ****   B64 (204), B64 (205), B64 (206), B64 (207),
 278:base64url.c   ****   B64 (208), B64 (209), B64 (210), B64 (211),
 279:base64url.c   ****   B64 (212), B64 (213), B64 (214), B64 (215),
 280:base64url.c   ****   B64 (216), B64 (217), B64 (218), B64 (219),
 281:base64url.c   ****   B64 (220), B64 (221), B64 (222), B64 (223),
 282:base64url.c   ****   B64 (224), B64 (225), B64 (226), B64 (227),
 283:base64url.c   ****   B64 (228), B64 (229), B64 (230), B64 (231),
 284:base64url.c   ****   B64 (232), B64 (233), B64 (234), B64 (235),
 285:base64url.c   ****   B64 (236), B64 (237), B64 (238), B64 (239),
 286:base64url.c   ****   B64 (240), B64 (241), B64 (242), B64 (243),
 287:base64url.c   ****   B64 (244), B64 (245), B64 (246), B64 (247),
 288:base64url.c   ****   B64 (248), B64 (249), B64 (250), B64 (251),
 289:base64url.c   ****   B64 (252), B64 (253), B64 (254), B64 (255)
 290:base64url.c   **** };
 291:base64url.c   **** 
 292:base64url.c   **** #if UCHAR_MAX == 255
 293:base64url.c   **** # define uchar_in_range(c) true
 294:base64url.c   **** #else
 295:base64url.c   **** # define uchar_in_range(c) ((c) <= 255)
 296:base64url.c   **** #endif
 297:base64url.c   **** 
 298:base64url.c   **** /* Return true if CH is a character from the Base64 alphabet, and
 299:base64url.c   ****    false otherwise.  Note that '=' is padding and not considered to be
 300:base64url.c   ****    part of the alphabet.  */
 301:base64url.c   **** bool
 302:base64url.c   **** isbase64 (char ch)
 303:base64url.c   **** {
 294              		.loc 1 303 0
 295              		.cfi_startproc
 296              		@ args = 0, pretend = 0, frame = 0
 297              		@ frame_needed = 0, uses_anonymous_args = 0
 298              		@ link register save eliminated.
 299              	.LVL41:
 304:base64url.c   ****   return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];
 300              		.loc 1 304 0
 301 0000 034B     		ldr	r3, .L28
 302 0002 1844     		add	r0, r0, r3
 303              	.LVL42:
 304 0004 90F84000 		ldrb	r0, [r0, #64]	@ zero_extendqisi2
 305 0008 C043     		mvns	r0, r0
 305:base64url.c   **** }
 306              		.loc 1 305 0
 307 000a C0F3C010 		ubfx	r0, r0, #7, #1
 308 000e 7047     		bx	lr
 309              	.L29:
 310              		.align	2
 311              	.L28:
 312 0010 00000000 		.word	.LANCHOR0
 313              		.cfi_endproc
 314              	.LFE3:
 316              		.section	.text.base64_decode,"ax",%progbits
 317              		.align	1
 318              		.global	base64_decode
 319              		.syntax unified
 320              		.thumb
 321              		.thumb_func
 322              		.fpu fpv4-sp-d16
 324              	base64_decode:
 325              	.LFB4:
 306:base64url.c   **** 
 307:base64url.c   **** /* Decode base64 encoded input array IN of length INLEN to output
 308:base64url.c   ****    array OUT that can hold *OUTLEN bytes.  Return true if decoding was
 309:base64url.c   ****    successful, i.e. if the input was valid base64 data, false
 310:base64url.c   ****    otherwise.  If *OUTLEN is too small, as many bytes as possible will
 311:base64url.c   ****    be written to OUT.  On return, *OUTLEN holds the length of decoded
 312:base64url.c   ****    bytes in OUT.  Note that as soon as any non-alphabet characters are
 313:base64url.c   ****    encountered, decoding is stopped and false is returned.  This means
 314:base64url.c   ****    that, when applicable, you must remove any line terminators that is
 315:base64url.c   ****    part of the data stream before calling this function.  */
 316:base64url.c   **** bool
 317:base64url.c   **** base64_decode (const char *restrict in, size_t inlen,
 318:base64url.c   **** 	       char *restrict out, size_t *outlen)
 319:base64url.c   **** {
 326              		.loc 1 319 0
 327              		.cfi_startproc
 328              		@ args = 0, pretend = 0, frame = 0
 329              		@ frame_needed = 0, uses_anonymous_args = 0
 330              	.LVL43:
 331 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 332              	.LCFI3:
 333              		.cfi_def_cfa_offset 24
 334              		.cfi_offset 4, -24
 335              		.cfi_offset 5, -20
 336              		.cfi_offset 6, -16
 337              		.cfi_offset 7, -12
 338              		.cfi_offset 8, -8
 339              		.cfi_offset 14, -4
 320:base64url.c   ****   size_t outleft = *outlen;
 340              		.loc 1 320 0
 341 0004 D3F800C0 		ldr	ip, [r3]
 342              	.LVL44:
 321:base64url.c   **** 
 322:base64url.c   ****   while (inlen >= 2)
 343              		.loc 1 322 0
 344 0008 0129     		cmp	r1, #1
 345 000a 63D9     		bls	.L40
 346              	.LVL45:
 347              	.LBB36:
 348              	.LBB37:
 304:base64url.c   **** }
 349              		.loc 1 304 0
 350 000c 0578     		ldrb	r5, [r0]	@ zero_extendqisi2
 351 000e 344C     		ldr	r4, .L47
 352 0010 2C44     		add	r4, r4, r5
 353 0012 94F94060 		ldrsb	r6, [r4, #64]
 354              	.LVL46:
 355              	.LBE37:
 356              	.LBE36:
 323:base64url.c   ****     {
 324:base64url.c   ****       if (!isbase64 (in[0]) || !isbase64 (in[1]))
 357              		.loc 1 324 0
 358 0016 002E     		cmp	r6, #0
 359 0018 5EDB     		blt	.L41
 360              	.LVL47:
 361              	.LBB39:
 362              	.LBB40:
 304:base64url.c   **** }
 363              		.loc 1 304 0
 364 001a 4578     		ldrb	r5, [r0, #1]	@ zero_extendqisi2
 365 001c 304C     		ldr	r4, .L47
 366 001e 2C44     		add	r4, r4, r5
 367 0020 94F940E0 		ldrsb	lr, [r4, #64]
 368              	.LVL48:
 369              	.LBE40:
 370              	.LBE39:
 371              		.loc 1 324 0
 372 0024 BEF1000F 		cmp	lr, #0
 373 0028 58DB     		blt	.L42
 320:base64url.c   **** 
 374              		.loc 1 320 0
 375 002a 6546     		mov	r5, ip
 376              	.LBB42:
 377              	.LBB43:
 304:base64url.c   **** }
 378              		.loc 1 304 0
 379 002c 2C4F     		ldr	r7, .L47
 380 002e 21E0     		b	.L32
 381              	.LVL49:
 382              	.L45:
 383              	.LBE43:
 384              	.LBE42:
 325:base64url.c   **** 	break;
 326:base64url.c   **** 
 327:base64url.c   ****       if (outleft)
 328:base64url.c   **** 	{
 329:base64url.c   **** 	  *out++ = ((b64[to_uchar (in[0])] << 2)
 330:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 331:base64url.c   **** 	  outleft--;
 332:base64url.c   **** 	}
 333:base64url.c   **** 
 334:base64url.c   ****       if (inlen == 2)
 335:base64url.c   **** 	break;
 336:base64url.c   **** 
 337:base64url.c   ****       if (in[2] == '=')
 338:base64url.c   **** 	{
 339:base64url.c   **** 	  if (inlen != 4)
 385              		.loc 1 339 0
 386 0030 0429     		cmp	r1, #4
 387 0032 03D1     		bne	.L31
 340:base64url.c   **** 	    break;
 341:base64url.c   **** 
 342:base64url.c   **** 	  if (in[3] != '=')
 388              		.loc 1 342 0
 389 0034 E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 390              	.LVL50:
 391 0036 3D2A     		cmp	r2, #61
 392 0038 00D1     		bne	.L31
 393              	.L35:
 394              	.LVL51:
 343:base64url.c   **** 	    break;
 344:base64url.c   **** 
 345:base64url.c   **** 	}
 346:base64url.c   ****       else
 347:base64url.c   **** 	{
 348:base64url.c   **** 	  if (!isbase64 (in[2]))
 349:base64url.c   **** 	    break;
 350:base64url.c   **** 
 351:base64url.c   **** 	  if (outleft)
 352:base64url.c   **** 	    {
 353:base64url.c   **** 	      *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)
 354:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 355:base64url.c   **** 	      outleft--;
 356:base64url.c   **** 	    }
 357:base64url.c   **** 
 358:base64url.c   **** 	  if (inlen == 3)
 359:base64url.c   **** 	    break;
 360:base64url.c   **** 
 361:base64url.c   **** 	  if (in[3] == '=')
 362:base64url.c   **** 	    {
 363:base64url.c   **** 	      if (inlen != 4)
 364:base64url.c   **** 		break;
 365:base64url.c   **** 	    }
 366:base64url.c   **** 	  else
 367:base64url.c   **** 	    {
 368:base64url.c   **** 	      if (!isbase64 (in[3]))
 369:base64url.c   **** 		break;
 370:base64url.c   **** 
 371:base64url.c   **** 	      if (outleft)
 372:base64url.c   **** 		{
 373:base64url.c   **** 		  *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)
 374:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 375:base64url.c   **** 		  outleft--;
 376:base64url.c   **** 		}
 377:base64url.c   **** 	    }
 378:base64url.c   **** 	}
 379:base64url.c   **** 
 380:base64url.c   ****       in += 4;
 381:base64url.c   ****       inlen -= 4;
 395              		.loc 1 381 0
 396 003a 0439     		subs	r1, r1, #4
 397              	.LVL52:
 398              	.L31:
 382:base64url.c   ****     }
 383:base64url.c   **** 
 384:base64url.c   ****   *outlen -= outleft;
 399              		.loc 1 384 0
 400 003c ACEB0505 		sub	r5, ip, r5
 401              	.LVL53:
 402 0040 1D60     		str	r5, [r3]
 403 0042 B1FA81F0 		clz	r0, r1
 404 0046 4009     		lsrs	r0, r0, #5
 385:base64url.c   **** 
 386:base64url.c   ****   if (inlen != 0)
 387:base64url.c   ****     return false;
 388:base64url.c   **** 
 389:base64url.c   ****   return true;
 390:base64url.c   **** }
 405              		.loc 1 390 0
 406 0048 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 407              	.LVL54:
 408              	.L46:
 363:base64url.c   **** 		break;
 409              		.loc 1 363 0
 410 004c 0429     		cmp	r1, #4
 411 004e F4D0     		beq	.L35
 412 0050 F4E7     		b	.L31
 413              	.L38:
 414              	.LVL55:
 381:base64url.c   ****     }
 415              		.loc 1 381 0
 416 0052 0439     		subs	r1, r1, #4
 417              	.LVL56:
 322:base64url.c   ****     {
 418              		.loc 1 322 0
 419 0054 0129     		cmp	r1, #1
 420 0056 F1D9     		bls	.L31
 421              	.LVL57:
 422              	.LBB45:
 423              	.LBB38:
 304:base64url.c   **** }
 424              		.loc 1 304 0
 425 0058 2679     		ldrb	r6, [r4, #4]	@ zero_extendqisi2
 426 005a 3E44     		add	r6, r6, r7
 427 005c 96F94060 		ldrsb	r6, [r6, #64]
 428              	.LVL58:
 429              	.LBE38:
 430              	.LBE45:
 324:base64url.c   **** 	break;
 431              		.loc 1 324 0
 432 0060 002E     		cmp	r6, #0
 433 0062 EBDB     		blt	.L31
 434              	.LVL59:
 435              	.LBB46:
 436              	.LBB41:
 304:base64url.c   **** }
 437              		.loc 1 304 0 discriminator 1
 438 0064 6479     		ldrb	r4, [r4, #5]	@ zero_extendqisi2
 439 0066 3C44     		add	r4, r4, r7
 440 0068 94F940E0 		ldrsb	lr, [r4, #64]
 441              	.LVL60:
 442 006c 0430     		adds	r0, r0, #4
 443              	.LVL61:
 444              	.LBE41:
 445              	.LBE46:
 324:base64url.c   **** 	break;
 446              		.loc 1 324 0 discriminator 1
 447 006e BEF1000F 		cmp	lr, #0
 448 0072 E3DB     		blt	.L31
 449              	.LVL62:
 450              	.L32:
 451 0074 0446     		mov	r4, r0
 452              	.LVL63:
 327:base64url.c   **** 	{
 453              		.loc 1 327 0
 454 0076 35B1     		cbz	r5, .L33
 455              	.LVL64:
 330:base64url.c   **** 	  outleft--;
 456              		.loc 1 330 0
 457 0078 4FEA2E18 		asr	r8, lr, #4
 458 007c 48EA8606 		orr	r6, r8, r6, lsl #2
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 459              		.loc 1 329 0
 460 0080 1670     		strb	r6, [r2]
 331:base64url.c   **** 	}
 461              		.loc 1 331 0
 462 0082 013D     		subs	r5, r5, #1
 463              	.LVL65:
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 464              		.loc 1 329 0
 465 0084 0132     		adds	r2, r2, #1
 466              	.LVL66:
 467              	.L33:
 334:base64url.c   **** 	break;
 468              		.loc 1 334 0
 469 0086 0229     		cmp	r1, #2
 470 0088 D8D0     		beq	.L31
 337:base64url.c   **** 	{
 471              		.loc 1 337 0
 472 008a A678     		ldrb	r6, [r4, #2]	@ zero_extendqisi2
 473 008c 3D2E     		cmp	r6, #61
 474 008e CFD0     		beq	.L45
 475              	.LVL67:
 476              	.LBB47:
 477              	.LBB44:
 304:base64url.c   **** }
 478              		.loc 1 304 0
 479 0090 3E44     		add	r6, r6, r7
 480              	.LVL68:
 481 0092 96F94080 		ldrsb	r8, [r6, #64]
 482              	.LVL69:
 483              	.LBE44:
 484              	.LBE47:
 348:base64url.c   **** 	    break;
 485              		.loc 1 348 0
 486 0096 B8F1000F 		cmp	r8, #0
 487 009a CFDB     		blt	.L31
 351:base64url.c   **** 	    {
 488              		.loc 1 351 0
 489 009c 3DB1     		cbz	r5, .L36
 490              	.LVL70:
 354:base64url.c   **** 	      outleft--;
 491              		.loc 1 354 0
 492 009e 4FEAA806 		asr	r6, r8, #2
 493 00a2 46EA0E1E 		orr	lr, r6, lr, lsl #4
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 494              		.loc 1 353 0
 495 00a6 82F800E0 		strb	lr, [r2]
 355:base64url.c   **** 	    }
 496              		.loc 1 355 0
 497 00aa 013D     		subs	r5, r5, #1
 498              	.LVL71:
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 499              		.loc 1 353 0
 500 00ac 0132     		adds	r2, r2, #1
 501              	.LVL72:
 502              	.L36:
 358:base64url.c   **** 	    break;
 503              		.loc 1 358 0
 504 00ae 0329     		cmp	r1, #3
 505 00b0 C4D0     		beq	.L31
 361:base64url.c   **** 	    {
 506              		.loc 1 361 0
 507 00b2 E678     		ldrb	r6, [r4, #3]	@ zero_extendqisi2
 508 00b4 3D2E     		cmp	r6, #61
 509 00b6 C9D0     		beq	.L46
 510              	.LVL73:
 511              	.LBB48:
 512              	.LBB49:
 304:base64url.c   **** }
 513              		.loc 1 304 0
 514 00b8 3E44     		add	r6, r6, r7
 515              	.LVL74:
 516 00ba 96F94060 		ldrsb	r6, [r6, #64]
 517              	.LVL75:
 518              	.LBE49:
 519              	.LBE48:
 368:base64url.c   **** 		break;
 520              		.loc 1 368 0
 521 00be 002E     		cmp	r6, #0
 522 00c0 BCDB     		blt	.L31
 371:base64url.c   **** 		{
 523              		.loc 1 371 0
 524 00c2 002D     		cmp	r5, #0
 525 00c4 C5D0     		beq	.L38
 526              	.LVL76:
 374:base64url.c   **** 		  outleft--;
 527              		.loc 1 374 0
 528 00c6 46EA8818 		orr	r8, r6, r8, lsl #6
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 529              		.loc 1 373 0
 530 00ca 82F80080 		strb	r8, [r2]
 375:base64url.c   **** 		}
 531              		.loc 1 375 0
 532 00ce 013D     		subs	r5, r5, #1
 533              	.LVL77:
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 534              		.loc 1 373 0
 535 00d0 0132     		adds	r2, r2, #1
 536              	.LVL78:
 537 00d2 BEE7     		b	.L38
 538              	.LVL79:
 539              	.L40:
 320:base64url.c   **** 
 540              		.loc 1 320 0
 541 00d4 6546     		mov	r5, ip
 542 00d6 B1E7     		b	.L31
 543              	.L41:
 544 00d8 6546     		mov	r5, ip
 545 00da AFE7     		b	.L31
 546              	.L42:
 547 00dc 6546     		mov	r5, ip
 548 00de ADE7     		b	.L31
 549              	.L48:
 550              		.align	2
 551              	.L47:
 552 00e0 00000000 		.word	.LANCHOR0
 553              		.cfi_endproc
 554              	.LFE4:
 556              		.section	.text.base64_decode_alloc,"ax",%progbits
 557              		.align	1
 558              		.global	base64_decode_alloc
 559              		.syntax unified
 560              		.thumb
 561              		.thumb_func
 562              		.fpu fpv4-sp-d16
 564              	base64_decode_alloc:
 565              	.LFB5:
 391:base64url.c   **** 
 392:base64url.c   **** /* Allocate an output buffer in *OUT, and decode the base64 encoded
 393:base64url.c   ****    data stored in IN of size INLEN to the *OUT buffer.  On return, the
 394:base64url.c   ****    size of the decoded data is stored in *OUTLEN.  OUTLEN may be NULL,
 395:base64url.c   ****    if the caller is not interested in the decoded length.  *OUT may be
 396:base64url.c   ****    NULL to indicate an out of memory error, in which case *OUTLEN
 397:base64url.c   ****    contains the size of the memory block needed.  The function returns
 398:base64url.c   ****    true on successful decoding and memory allocation errors.  (Use the
 399:base64url.c   ****    *OUT and *OUTLEN parameters to differentiate between successful
 400:base64url.c   ****    decoding and memory error.)  The function returns false if the
 401:base64url.c   ****    input was invalid, in which case *OUT is NULL and *OUTLEN is
 402:base64url.c   ****    undefined. */
 403:base64url.c   **** bool
 404:base64url.c   **** base64_decode_alloc (const char *in, size_t inlen, char **out,
 405:base64url.c   **** 		     size_t *outlen)
 406:base64url.c   **** {
 566              		.loc 1 406 0
 567              		.cfi_startproc
 568              		@ args = 0, pretend = 0, frame = 8
 569              		@ frame_needed = 0, uses_anonymous_args = 0
 570              	.LVL80:
 571 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 572              	.LCFI4:
 573              		.cfi_def_cfa_offset 20
 574              		.cfi_offset 4, -20
 575              		.cfi_offset 5, -16
 576              		.cfi_offset 6, -12
 577              		.cfi_offset 7, -8
 578              		.cfi_offset 14, -4
 579 0002 83B0     		sub	sp, sp, #12
 580              	.LCFI5:
 581              		.cfi_def_cfa_offset 32
 582 0004 0746     		mov	r7, r0
 583 0006 0C46     		mov	r4, r1
 584 0008 1546     		mov	r5, r2
 585 000a 1E46     		mov	r6, r3
 407:base64url.c   ****   /* This may allocate a few bytes too much, depending on input,
 408:base64url.c   ****      but it's not worth the extra CPU time to compute the exact amount.
 409:base64url.c   ****      The exact amount is 3 * inlen / 4, minus 1 if the input ends
 410:base64url.c   ****      with "=" and minus another 1 if the input ends with "==".
 411:base64url.c   ****      Dividing before multiplying avoids the possibility of overflow.  */
 412:base64url.c   ****   size_t needlen = 3 * (inlen / 4) + 2;
 586              		.loc 1 412 0
 587 000c 8808     		lsrs	r0, r1, #2
 588              	.LVL81:
 589 000e 00EB4000 		add	r0, r0, r0, lsl #1
 590 0012 0230     		adds	r0, r0, #2
 591 0014 0190     		str	r0, [sp, #4]
 413:base64url.c   **** 
 414:base64url.c   ****   *out = malloc (needlen);
 592              		.loc 1 414 0
 593 0016 FFF7FEFF 		bl	malloc
 594              	.LVL82:
 595 001a 2860     		str	r0, [r5]
 415:base64url.c   ****   if (!*out)
 596              		.loc 1 415 0
 597 001c 88B1     		cbz	r0, .L52
 416:base64url.c   ****     return true;
 417:base64url.c   **** 
 418:base64url.c   ****   if (!base64_decode (in, inlen, *out, &needlen))
 598              		.loc 1 418 0
 599 001e 01AB     		add	r3, sp, #4
 600 0020 0246     		mov	r2, r0
 601 0022 2146     		mov	r1, r4
 602 0024 3846     		mov	r0, r7
 603 0026 FFF7FEFF 		bl	base64_decode
 604              	.LVL83:
 605 002a 0446     		mov	r4, r0
 606              	.LVL84:
 607 002c 18B1     		cbz	r0, .L54
 419:base64url.c   ****     {
 420:base64url.c   ****       free (*out);
 421:base64url.c   ****       *out = NULL;
 422:base64url.c   ****       return false;
 423:base64url.c   ****     }
 424:base64url.c   **** 
 425:base64url.c   ****   if (outlen)
 608              		.loc 1 425 0
 609 002e 4EB1     		cbz	r6, .L50
 426:base64url.c   ****     *outlen = needlen;
 610              		.loc 1 426 0
 611 0030 019B     		ldr	r3, [sp, #4]
 612 0032 3360     		str	r3, [r6]
 613 0034 06E0     		b	.L50
 614              	.L54:
 420:base64url.c   ****       *out = NULL;
 615              		.loc 1 420 0
 616 0036 2868     		ldr	r0, [r5]
 617 0038 FFF7FEFF 		bl	free
 618              	.LVL85:
 421:base64url.c   ****       return false;
 619              		.loc 1 421 0
 620 003c 0023     		movs	r3, #0
 621 003e 2B60     		str	r3, [r5]
 422:base64url.c   ****     }
 622              		.loc 1 422 0
 623 0040 00E0     		b	.L50
 624              	.LVL86:
 625              	.L52:
 416:base64url.c   **** 
 626              		.loc 1 416 0
 627 0042 0124     		movs	r4, #1
 628              	.LVL87:
 629              	.L50:
 427:base64url.c   **** 
 428:base64url.c   ****   return true;
 429:base64url.c   **** }
 630              		.loc 1 429 0
 631 0044 2046     		mov	r0, r4
 632 0046 03B0     		add	sp, sp, #12
 633              	.LCFI6:
 634              		.cfi_def_cfa_offset 20
 635              		@ sp needed
 636 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
 637              		.cfi_endproc
 638              	.LFE5:
 640              		.section	.rodata
 641              		.align	2
 642              		.set	.LANCHOR0,. + 0
 645              	b64str.6030:
 646 0000 41424344 		.ascii	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy"
 646      45464748 
 646      494A4B4C 
 646      4D4E4F50 
 646      51525354 
 647 0033 7A303132 		.ascii	"z0123456789-_"
 647      33343536 
 647      3738392D 
 647      5F
 650              	b64:
 651 0040 FF       		.byte	-1
 652 0041 FF       		.byte	-1
 653 0042 FF       		.byte	-1
 654 0043 FF       		.byte	-1
 655 0044 FF       		.byte	-1
 656 0045 FF       		.byte	-1
 657 0046 FF       		.byte	-1
 658 0047 FF       		.byte	-1
 659 0048 FF       		.byte	-1
 660 0049 FF       		.byte	-1
 661 004a FF       		.byte	-1
 662 004b FF       		.byte	-1
 663 004c FF       		.byte	-1
 664 004d FF       		.byte	-1
 665 004e FF       		.byte	-1
 666 004f FF       		.byte	-1
 667 0050 FF       		.byte	-1
 668 0051 FF       		.byte	-1
 669 0052 FF       		.byte	-1
 670 0053 FF       		.byte	-1
 671 0054 FF       		.byte	-1
 672 0055 FF       		.byte	-1
 673 0056 FF       		.byte	-1
 674 0057 FF       		.byte	-1
 675 0058 FF       		.byte	-1
 676 0059 FF       		.byte	-1
 677 005a FF       		.byte	-1
 678 005b FF       		.byte	-1
 679 005c FF       		.byte	-1
 680 005d FF       		.byte	-1
 681 005e FF       		.byte	-1
 682 005f FF       		.byte	-1
 683 0060 FF       		.byte	-1
 684 0061 FF       		.byte	-1
 685 0062 FF       		.byte	-1
 686 0063 FF       		.byte	-1
 687 0064 FF       		.byte	-1
 688 0065 FF       		.byte	-1
 689 0066 FF       		.byte	-1
 690 0067 FF       		.byte	-1
 691 0068 FF       		.byte	-1
 692 0069 FF       		.byte	-1
 693 006a FF       		.byte	-1
 694 006b FF       		.byte	-1
 695 006c FF       		.byte	-1
 696 006d 3E       		.byte	62
 697 006e FF       		.byte	-1
 698 006f FF       		.byte	-1
 699 0070 34       		.byte	52
 700 0071 35       		.byte	53
 701 0072 36       		.byte	54
 702 0073 37       		.byte	55
 703 0074 38       		.byte	56
 704 0075 39       		.byte	57
 705 0076 3A       		.byte	58
 706 0077 3B       		.byte	59
 707 0078 3C       		.byte	60
 708 0079 3D       		.byte	61
 709 007a FF       		.byte	-1
 710 007b FF       		.byte	-1
 711 007c FF       		.byte	-1
 712 007d FF       		.byte	-1
 713 007e FF       		.byte	-1
 714 007f FF       		.byte	-1
 715 0080 FF       		.byte	-1
 716 0081 00       		.byte	0
 717 0082 01       		.byte	1
 718 0083 02       		.byte	2
 719 0084 03       		.byte	3
 720 0085 04       		.byte	4
 721 0086 05       		.byte	5
 722 0087 06       		.byte	6
 723 0088 07       		.byte	7
 724 0089 08       		.byte	8
 725 008a 09       		.byte	9
 726 008b 0A       		.byte	10
 727 008c 0B       		.byte	11
 728 008d 0C       		.byte	12
 729 008e 0D       		.byte	13
 730 008f 0E       		.byte	14
 731 0090 0F       		.byte	15
 732 0091 10       		.byte	16
 733 0092 11       		.byte	17
 734 0093 12       		.byte	18
 735 0094 13       		.byte	19
 736 0095 14       		.byte	20
 737 0096 15       		.byte	21
 738 0097 16       		.byte	22
 739 0098 17       		.byte	23
 740 0099 18       		.byte	24
 741 009a 19       		.byte	25
 742 009b FF       		.byte	-1
 743 009c FF       		.byte	-1
 744 009d FF       		.byte	-1
 745 009e FF       		.byte	-1
 746 009f 3F       		.byte	63
 747 00a0 FF       		.byte	-1
 748 00a1 1A       		.byte	26
 749 00a2 1B       		.byte	27
 750 00a3 1C       		.byte	28
 751 00a4 1D       		.byte	29
 752 00a5 1E       		.byte	30
 753 00a6 1F       		.byte	31
 754 00a7 20       		.byte	32
 755 00a8 21       		.byte	33
 756 00a9 22       		.byte	34
 757 00aa 23       		.byte	35
 758 00ab 24       		.byte	36
 759 00ac 25       		.byte	37
 760 00ad 26       		.byte	38
 761 00ae 27       		.byte	39
 762 00af 28       		.byte	40
 763 00b0 29       		.byte	41
 764 00b1 2A       		.byte	42
 765 00b2 2B       		.byte	43
 766 00b3 2C       		.byte	44
 767 00b4 2D       		.byte	45
 768 00b5 2E       		.byte	46
 769 00b6 2F       		.byte	47
 770 00b7 30       		.byte	48
 771 00b8 31       		.byte	49
 772 00b9 32       		.byte	50
 773 00ba 33       		.byte	51
 774 00bb FF       		.byte	-1
 775 00bc FF       		.byte	-1
 776 00bd FF       		.byte	-1
 777 00be FF       		.byte	-1
 778 00bf FF       		.byte	-1
 779 00c0 FF       		.byte	-1
 780 00c1 FF       		.byte	-1
 781 00c2 FF       		.byte	-1
 782 00c3 FF       		.byte	-1
 783 00c4 FF       		.byte	-1
 784 00c5 FF       		.byte	-1
 785 00c6 FF       		.byte	-1
 786 00c7 FF       		.byte	-1
 787 00c8 FF       		.byte	-1
 788 00c9 FF       		.byte	-1
 789 00ca FF       		.byte	-1
 790 00cb FF       		.byte	-1
 791 00cc FF       		.byte	-1
 792 00cd FF       		.byte	-1
 793 00ce FF       		.byte	-1
 794 00cf FF       		.byte	-1
 795 00d0 FF       		.byte	-1
 796 00d1 FF       		.byte	-1
 797 00d2 FF       		.byte	-1
 798 00d3 FF       		.byte	-1
 799 00d4 FF       		.byte	-1
 800 00d5 FF       		.byte	-1
 801 00d6 FF       		.byte	-1
 802 00d7 FF       		.byte	-1
 803 00d8 FF       		.byte	-1
 804 00d9 FF       		.byte	-1
 805 00da FF       		.byte	-1
 806 00db FF       		.byte	-1
 807 00dc FF       		.byte	-1
 808 00dd FF       		.byte	-1
 809 00de FF       		.byte	-1
 810 00df FF       		.byte	-1
 811 00e0 FF       		.byte	-1
 812 00e1 FF       		.byte	-1
 813 00e2 FF       		.byte	-1
 814 00e3 FF       		.byte	-1
 815 00e4 FF       		.byte	-1
 816 00e5 FF       		.byte	-1
 817 00e6 FF       		.byte	-1
 818 00e7 FF       		.byte	-1
 819 00e8 FF       		.byte	-1
 820 00e9 FF       		.byte	-1
 821 00ea FF       		.byte	-1
 822 00eb FF       		.byte	-1
 823 00ec FF       		.byte	-1
 824 00ed FF       		.byte	-1
 825 00ee FF       		.byte	-1
 826 00ef FF       		.byte	-1
 827 00f0 FF       		.byte	-1
 828 00f1 FF       		.byte	-1
 829 00f2 FF       		.byte	-1
 830 00f3 FF       		.byte	-1
 831 00f4 FF       		.byte	-1
 832 00f5 FF       		.byte	-1
 833 00f6 FF       		.byte	-1
 834 00f7 FF       		.byte	-1
 835 00f8 FF       		.byte	-1
 836 00f9 FF       		.byte	-1
 837 00fa FF       		.byte	-1
 838 00fb FF       		.byte	-1
 839 00fc FF       		.byte	-1
 840 00fd FF       		.byte	-1
 841 00fe FF       		.byte	-1
 842 00ff FF       		.byte	-1
 843 0100 FF       		.byte	-1
 844 0101 FF       		.byte	-1
 845 0102 FF       		.byte	-1
 846 0103 FF       		.byte	-1
 847 0104 FF       		.byte	-1
 848 0105 FF       		.byte	-1
 849 0106 FF       		.byte	-1
 850 0107 FF       		.byte	-1
 851 0108 FF       		.byte	-1
 852 0109 FF       		.byte	-1
 853 010a FF       		.byte	-1
 854 010b FF       		.byte	-1
 855 010c FF       		.byte	-1
 856 010d FF       		.byte	-1
 857 010e FF       		.byte	-1
 858 010f FF       		.byte	-1
 859 0110 FF       		.byte	-1
 860 0111 FF       		.byte	-1
 861 0112 FF       		.byte	-1
 862 0113 FF       		.byte	-1
 863 0114 FF       		.byte	-1
 864 0115 FF       		.byte	-1
 865 0116 FF       		.byte	-1
 866 0117 FF       		.byte	-1
 867 0118 FF       		.byte	-1
 868 0119 FF       		.byte	-1
 869 011a FF       		.byte	-1
 870 011b FF       		.byte	-1
 871 011c FF       		.byte	-1
 872 011d FF       		.byte	-1
 873 011e FF       		.byte	-1
 874 011f FF       		.byte	-1
 875 0120 FF       		.byte	-1
 876 0121 FF       		.byte	-1
 877 0122 FF       		.byte	-1
 878 0123 FF       		.byte	-1
 879 0124 FF       		.byte	-1
 880 0125 FF       		.byte	-1
 881 0126 FF       		.byte	-1
 882 0127 FF       		.byte	-1
 883 0128 FF       		.byte	-1
 884 0129 FF       		.byte	-1
 885 012a FF       		.byte	-1
 886 012b FF       		.byte	-1
 887 012c FF       		.byte	-1
 888 012d FF       		.byte	-1
 889 012e FF       		.byte	-1
 890 012f FF       		.byte	-1
 891 0130 FF       		.byte	-1
 892 0131 FF       		.byte	-1
 893 0132 FF       		.byte	-1
 894 0133 FF       		.byte	-1
 895 0134 FF       		.byte	-1
 896 0135 FF       		.byte	-1
 897 0136 FF       		.byte	-1
 898 0137 FF       		.byte	-1
 899 0138 FF       		.byte	-1
 900 0139 FF       		.byte	-1
 901 013a FF       		.byte	-1
 902 013b FF       		.byte	-1
 903 013c FF       		.byte	-1
 904 013d FF       		.byte	-1
 905 013e FF       		.byte	-1
 906 013f FF       		.byte	-1
 907              		.text
 908              	.Letext0:
 909              		.file 2 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 910              		.file 3 "/usr/arm-none-eabi/include/sys/lock.h"
 911              		.file 4 "/usr/arm-none-eabi/include/sys/_types.h"
 912              		.file 5 "/usr/arm-none-eabi/include/sys/reent.h"
 913              		.file 6 "/usr/arm-none-eabi/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 base64url.c
     /tmp/cckv0KJm.s:17     .text.base64_encode:0000000000000000 $t
     /tmp/cckv0KJm.s:24     .text.base64_encode:0000000000000000 base64_encode
     /tmp/cckv0KJm.s:204    .text.base64_encode:00000000000000b8 $d
     /tmp/cckv0KJm.s:209    .text.base64_encode_alloc:0000000000000000 $t
     /tmp/cckv0KJm.s:216    .text.base64_encode_alloc:0000000000000000 base64_encode_alloc
     /tmp/cckv0KJm.s:280    .text.base64_encode_alloc:0000000000000044 $d
     /tmp/cckv0KJm.s:285    .text.isbase64:0000000000000000 $t
     /tmp/cckv0KJm.s:292    .text.isbase64:0000000000000000 isbase64
     /tmp/cckv0KJm.s:312    .text.isbase64:0000000000000010 $d
     /tmp/cckv0KJm.s:317    .text.base64_decode:0000000000000000 $t
     /tmp/cckv0KJm.s:324    .text.base64_decode:0000000000000000 base64_decode
     /tmp/cckv0KJm.s:552    .text.base64_decode:00000000000000e0 $d
     /tmp/cckv0KJm.s:557    .text.base64_decode_alloc:0000000000000000 $t
     /tmp/cckv0KJm.s:564    .text.base64_decode_alloc:0000000000000000 base64_decode_alloc
     /tmp/cckv0KJm.s:641    .rodata:0000000000000000 $d
     /tmp/cckv0KJm.s:645    .rodata:0000000000000000 b64str.6030
     /tmp/cckv0KJm.s:650    .rodata:0000000000000040 b64
                           .group:0000000000000000 wm4.0.36326cb9f2f282db52d0a8f4d7f6f490
                           .group:0000000000000000 wm4.stdbool.h.29.07dce69c3b78884144b7f7bd19483461
                           .group:0000000000000000 wm4.stddef.h.39.99b5021e28f91cdb161c889e07266673
                           .group:0000000000000000 wm4.base64url.h.26.ed1fee22e760dd991443f292d5830091
                           .group:0000000000000000 wm4.ieeefp.h.77.220d9cccac42cd58761758bee2df4ce6
                           .group:0000000000000000 wm4._newlib_version.h.4.875b979a44719054cd750d0952ad3fd6
                           .group:0000000000000000 wm4.newlib.h.18.5e5ca3429233af402d406a202f1fc1ac
                           .group:0000000000000000 wm4.features.h.22.026edb2397769f4ae13f35900dbdb560
                           .group:0000000000000000 wm4.config.h.220.6cac6a9685cfce5e83c17784171638d9
                           .group:0000000000000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.161.19e15733342b50ead2919490b095303e
                           .group:0000000000000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:0000000000000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:0000000000000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:0000000000000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:0000000000000000 wm4._types.h.184.03611d4f6b5bec9997bcf4279eceba07
                           .group:0000000000000000 wm4.reent.h.17.90c2574d4acdcfce933db5cb09ff35fe
                           .group:0000000000000000 wm4.cdefs.h.47.14fad0b327eb9dcf106599b738d85132
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.56.d4493cd3736e51e9d56335045f26df45
                           .group:0000000000000000 wm4.limits.h.2.a76e572559edc4d4305b1cf624158ea8
                           .group:0000000000000000 wm4.limits.h.60.56a1ae353e2028a24298ec6463b8b593

UNDEFINED SYMBOLS
malloc
free
